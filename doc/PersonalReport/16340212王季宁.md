# 期末个人报告

小组项目主要负责基础部分，即：

- 完成对模型中具体位置的控制模块设计
- 碰撞检测
- 更改模型
- 调整光源
- 添加粒子效果
- 添加碰撞音效

### 完成对模型中具体位置的控制模块设计

由于模型中具体物体较多，为了确定每个模型在meshes数组中的位置，通过手动搜索的方式建立了一个数组下标和对象之间的关联map，并分别渲染之。

```c++
void draw(Shader& shader,Shader &shader1,Shader &shader2,bool shadow,bool ball)
	{
		//printf("Circle: %f %f %f\n", bcircle.x, bcircle.y, hight);
		//cout << this->meshes.size() << endl;
		int i = 0;
		for (std::vector<Mesh>::iterator it = this->meshes.begin(); this->meshes.end() != it; ++it)
		{
			if (it->flag) {
				i++;
				continue;
			}
			if (shadow) {
				if ((it - meshes.begin()) == 32 && ball) it->draw(shader, glm::vec3(0.5f, 0.5f, 0.5f));
				else if (ball) continue;
				else if ((it - meshes.begin()) != 32) it->draw(shader, glm::vec3(0.0f, 0.5f, 0.5f));
			}
			else {
				if ((it - meshes.begin()) == 32) it->draw(shader1, glm::vec3(0.5f, 0.5f, 0.5f));
				else it->draw(shader, glm::vec3(0.0f, 0.5f, 0.5f));
			}
		}
		for (auto pair : this->Circles) {
			//判断是否发生了撞击事件
			if (!this->meshes[pair.first].flag && if_collision(this->bcircle, pair.second)) {
				if (this->meshes[pair.first].explode(shader2)) {
					this->meshes[pair.first].flag = true;
				}
				else {
					PlaySound("boom.wav", NULL, SND_ASYNC | SND_FILENAME);
					this->meshes[pair.first].draw(shader2, glm::vec3(1.0f, 1.0f, 1.0f));
				}
			}
		}
	}
```



### 碰撞检测

由于保龄球和球瓶的水平截面可以视为圆，因此保龄球和球瓶之间的碰撞可以简化为判断平面上两个圆之间的位置关系，类似地，保龄球与挡板之间的碰撞可以简化为判断平面上圆和线之间的位置关系。

```C++
#pragma once
#include <GLEW/glew.h>
#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <glm/gtx/string_cast.hpp>
#include <string>       
#include <vector>
#include <fstream>
#include <sstream>
#include <algorithm>
#include <assimp/Importer.hpp>
#include <assimp/scene.h>
#include <assimp/postprocess.h>
#include <iostream>
using namespace std;

// 表示一个圆的属性
struct Circle
{
	float x;
	float y;
	float r;
};

//给出圆周上的三个点，计算圆心和半径
Circle Calculate_circle(glm::vec2 px1, glm::vec2 px2, glm::vec2 px3) {
	float x1, y1, x2, y2, x3, y3;
	float a, b, c, g, e, f;
	x1 = px1.x;
	y1 = px1.y;
	x2 = px2.x;
	y2 = px2.y;
	x3 = px3.x;
	y3 = px3.y;
	e = 2 * (x2 - x1);
	f = 2 * (y2 - y1);
	g = x2 * x2 - x1 * x1 + y2 * y2 - y1 * y1;
	a = 2 * (x3 - x2);
	b = 2 * (y3 - y2);
	c = x3 * x3 - x2 * x2 + y3 * y3 - y2 * y2;
	float X = (g*b - c * f) / (e*b - a * f);
    float Y = (a*g - c * e) / (a*f - b * e);
	float R = sqrt((X - x1)*(X - x1) + (Y - y1)*(Y - y1));
	Circle cir;
	cir.x = X;
	cir.y = Y;
	cir.r = R;
	return cir;
}

//判断两个圆是否发生了碰撞
bool if_collision(Circle c1, Circle c2) {
	float distance = sqrt(pow((c1.x - c2.x), 2) + pow((c1.y-c2.y),2));
	float rsum = c1.r + c2.r;
	return distance <= rsum;
}
 
//判断圆是否和一条线碰撞了
bool if_collision(Circle c1, GLfloat line) {
	return (fabs(c1.x - line) <= c1.r || fabs(c1.y - line) <= c1.r);
}
```

计算圆心和半径

```C++
Circle get_circle(float height, float delta = 0) {
	vector<glm::vec2> points;
	for (auto & v : this->vertData) {
		if (v.position.y >= height - delta && v.position.y <= height + delta) {
			points.push_back(glm::vec2(v.position.x, v.position.z));
			if (points.size() == 100) {
				break;
			}
		}
	}
	//cout << "point num; " << points.size() << endl;
	Circle c = Calculate_circle(points[0], points[40], points[80]);
	//cout << c.x << " " << c.y << " " << c.r << endl;
	return c;
}
float get_height() {
	float min = 1000.0f;
	float max = 0.0f;
	for (auto & v : this->vertData) {
		if (min > v.position.y) {
			min = v.position.y;
		}
		if (max < v.position.y) {
			max = v.position.y;
		}
	}
	float center = (max + min) / 2;
	return center;
}
```

### 更改模型

该部分主要是对原来的模型不太满意，所以搜索了一些新的物体加入。

### 调整光源

对光源的参数进行调整，使得视觉效果更好。

### 添加粒子爆炸效果

加入几何着色器

```c++
#version 330 core
layout (triangles) in;
layout (triangle_strip, max_vertices = 3) out;

in VS_OUT {
    vec2 texCoords;
} gs_in[];

out vec2 TexCoords; 

uniform float time = 0;

vec4 explode(vec4 position, vec3 normal)
{
    float magnitude = 0.5f;
    vec3 direction = normal * (sin(time) + 1.0f) * magnitude; 
    return position + vec4(direction, 0.0f);
}

vec3 GetNormal()
{
    vec3 a = vec3(gl_in[0].gl_Position) - vec3(gl_in[1].gl_Position);
    vec3 b = vec3(gl_in[2].gl_Position) - vec3(gl_in[1].gl_Position);
    return normalize(cross(a, b));
}

void main() {    
    vec3 normal = GetNormal();
    gl_Position = explode(gl_in[0].gl_Position, normal);
    TexCoords = gs_in[0].texCoords;
    EmitVertex();
    gl_Position = explode(gl_in[1].gl_Position, normal);
    TexCoords = gs_in[1].texCoords;
    EmitVertex();
    gl_Position = explode(gl_in[2].gl_Position, normal);
    TexCoords = gs_in[2].texCoords;
    EmitVertex();
    EndPrimitive();
}
```

制造爆炸效果

```c++
bool explode(Shader& shader) {
	//time = glfwGetTime();
	time += 0.1f;
	if (time > 0.0f) {
		return true;
	}
	shader.SetFloat("time", time, true);
	return false;
}
```

### 添加碰撞音效

```c++
PlaySound("boom.wav", NULL, SND_ASYNC | SND_FILENAME);
```



### 问题和解决

遇到的主要困难是音效、碰撞检测和爆炸效果之前从未接触过，花了较多时间去查资料，为了与队友写的代码

融合也花了较长的时间debug。为了解决爆炸效果不明显的问题，我采取了扩大爆炸半径和加快爆炸速度的方案，取得较好的视觉效果。